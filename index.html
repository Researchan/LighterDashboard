<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>⚡ Lighter vs Binance Funding Arbitrage</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333; 
            min-height: 100vh;
            padding: 20px;
        }
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            background: rgba(255,255,255,0.95); 
            border-radius: 20px; 
            padding: 30px; 
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        .table-container { 
            overflow-x: auto; 
            border-radius: 15px; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.1); 
        }
        table { 
            width: 100%; 
            border-collapse: collapse; 
            background: white;
        }
        th, td { 
            padding: 16px 20px; 
            text-align: left; 
            border-bottom: 1px solid #f0f0f0; 
        }
        th { 
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white; 
            font-weight: 600; 
            font-size: 14px; 
            text-transform: uppercase; 
            letter-spacing: 0.5px;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .sortable { 
            cursor: pointer; 
            user-select: none;
            transition: background-color 0.2s;
        }
        .sortable:hover { 
            background: rgba(255,255,255,0.1); 
        }
        td { 
            font-size: 15px; 
            font-family: 'Monaco', 'Consolas', monospace;
        }
        .positive { 
            background: linear-gradient(90deg, rgba(34,197,94,0.1), rgba(34,197,94,0.05));
            color: #059669; 
            font-weight: 600;
        }
        .negative { 
            background: linear-gradient(90deg, rgba(239,68,68,0.1), rgba(239,68,68,0.05));
            color: #dc2626; 
            font-weight: 600;
        }
        .neutral { 
            color: #6b7280; 
        }
        tr:nth-child(even) { 
            background: #f8fafc; 
        }
        tr:hover { 
            background: #e0e7ff; 
            transform: translateY(-1px);
            transition: all 0.2s ease;
        }
        .update-time { 
            text-align: center; 
            margin-top: 20px; 
            color: #6b7280; 
            font-size: 14px;
        }
        .loading { 
            text-align: center; 
            color: #6b7280; 
            font-style: italic;
        }
        @media (max-width: 768px) {
            .container { padding: 15px; }
            th, td { padding: 12px 8px; font-size: 12px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Symbol</th>
                        <th class="sortable" data-sort="lighterFunding">Lighter (8h) ↕</th>
                        <th class="sortable" data-sort="binanceFunding">Binance (Interval) ↕</th>
                        <th class="sortable" data-sort="binanceFunding8h">Binance (8h eq) ↕</th>
                        <th class="sortable" data-sort="fundingDiff">Diff (8h) ↕</th>
                        <th>Next Funding</th>
                        <th>L Bid / B Ask</th>
                        <th>L Ask / B Bid</th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                    <tr class="loading">
                        <td colspan="8">Connecting to WebSocket...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
    <div class="update-time" id="updateTime">Last update: -</div>

    <script>
        // Complete orderbook state management
        const lighterOrderbooks = {}; // {symbol: {bids: Map, asks: Map}}
        const binanceData = {};
        const lighterFundingData = {};
        const lastValidLighterData = {}; // Store last valid Lighter orderbook data
        const lastValidBinanceData = {}; // Store last valid Binance data
        const symbolLastUpdate = {}; // Track last update time for each symbol
        const symbolSubscriptionStatus = {}; // Track subscription status per symbol
        let lighterMarkets = {};
        let binanceSymbolMap = {};
        
        // Throttled update mechanism
        let updateTimeout = null;
        function scheduleUpdate() {
            if (updateTimeout) return;
            updateTimeout = setTimeout(() => {
                updateTable();
                updateTimeout = null;
            }, 500); // Update every 500ms max
        }

        // Initialize orderbook for a symbol
        function initOrderbook(symbol) {
            if (!lighterOrderbooks[symbol]) {
                lighterOrderbooks[symbol] = {
                    bids: new Map(), // price -> size
                    asks: new Map(),  // price -> size
                    lastUpdate: Date.now()
                };
            }
        }
        
        // Function to validate and store orderbook data
        function validateAndStoreOrderbook(symbol, isLighter = true) {
            if (isLighter) {
                const orderbook = lighterOrderbooks[symbol];
                if (orderbook && orderbook.bids.size > 0 && orderbook.asks.size > 0) {
                    const bid = Math.max(...orderbook.bids.keys());
                    const ask = Math.min(...orderbook.asks.keys());
                    
                    // Only store if data looks valid
                    if (bid > 0 && ask > 0 && ask > bid) {
                        lastValidLighterData[symbol] = {
                            bid: bid,
                            ask: ask,
                            timestamp: Date.now()
                        };
                    }
                }
            } else {
                const data = binanceData[symbol];
                if (data && data.bid > 0 && data.ask > 0 && data.ask > data.bid) {
                    lastValidBinanceData[symbol] = {
                        ...data,
                        timestamp: Date.now()
                    };
                }
            }
        }

        // Apply incremental orderbook update
        function applyOrderbookUpdate(symbol, bids, asks) {
            initOrderbook(symbol);
            
            const orderbook = lighterOrderbooks[symbol];
            
            // Update bids
            if (bids && bids.length > 0) {
                bids.forEach(bid => {
                    const price = parseFloat(bid.price);
                    const size = parseFloat(bid.size);
                    
                    if (size === 0) {
                        orderbook.bids.delete(price); // Remove price level
                    } else {
                        orderbook.bids.set(price, size); // Add/update price level
                    }
                });
            }
            
            // Update asks
            if (asks && asks.length > 0) {
                asks.forEach(ask => {
                    const price = parseFloat(ask.price);
                    const size = parseFloat(ask.size);
                    
                    if (size === 0) {
                        orderbook.asks.delete(price); // Remove price level
                    } else {
                        orderbook.asks.set(price, size); // Add/update price level
                    }
                });
            }
            
            // Update last update time
            orderbook.lastUpdate = Date.now();
            symbolLastUpdate[symbol] = Date.now();
        }

        // Get best bid/ask from maintained orderbook
        function getBestPrices(symbol) {
            const orderbook = lighterOrderbooks[symbol];
            const MAX_AGE = 60000; // Extend to 60 seconds for better persistence
            
            // Get highest bid
            let bestBid = null;
            if (orderbook && orderbook.bids.size > 0) {
                bestBid = Math.max(...orderbook.bids.keys());
            }
            
            // Get lowest ask
            let bestAsk = null;
            if (orderbook && orderbook.asks.size > 0) {
                bestAsk = Math.min(...orderbook.asks.keys());
            }
            
            // Use last valid data if current data is unavailable but recent
            // This helps maintain display during brief disconnections
            if ((!bestBid || !bestAsk) && lastValidLighterData[symbol]) {
                const age = Date.now() - lastValidLighterData[symbol].timestamp;
                if (age < MAX_AGE) {
                    bestBid = bestBid || lastValidLighterData[symbol].bid;
                    bestAsk = bestAsk || lastValidLighterData[symbol].ask;
                }
            }
            
            return { bid: bestBid, ask: bestAsk };
        }

        // Store Binance funding intervals for each symbol
        let binanceFundingIntervals = {};
        let binanceListedSymbols = new Set(); // Track which symbols are actually listed on Binance
        
        // Fetch actual funding intervals from Binance fundingInfo API
        async function fetchBinanceFundingIntervals() {
            try {
                console.log('Fetching Binance funding intervals from fundingInfo API...');
                
                // Get funding info with actual intervals
                const response = await fetch('https://fapi.binance.com/fapi/v1/fundingInfo');
                const data = await response.json();
                
                if (Array.isArray(data)) {
                    let intervalCounts = { 1: 0, 4: 0, 8: 0 };
                    
                    // First, collect ALL Binance perpetual symbols
                    data.forEach(item => {
                        const symbol = item.symbol;
                        const fundingInterval = item.fundingIntervalHours;
                        
                        if (symbol && fundingInterval) {
                            binanceListedSymbols.add(symbol); // Track all listed symbols
                            binanceFundingIntervals[symbol] = fundingInterval;
                            intervalCounts[fundingInterval] = (intervalCounts[fundingInterval] || 0) + 1;
                        }
                    });
                    
                    console.log(`Binance has ${binanceListedSymbols.size} perpetual futures listed`);
                    console.log(`Loaded funding intervals: ${intervalCounts[1] || 0} symbols with 1h, ${intervalCounts[4] || 0} symbols with 4h, ${intervalCounts[8] || 0} symbols with 8h`);
                    
                    // Filter out unlisted symbols from our mapping
                    const unlistedSymbols = [];
                    Object.entries(binanceSymbolMap).forEach(([lighterSymbol, binanceSymbol]) => {
                        if (!binanceListedSymbols.has(binanceSymbol)) {
                            unlistedSymbols.push(lighterSymbol);
                            delete binanceSymbolMap[lighterSymbol]; // Remove unlisted pairs
                        }
                    });
                    
                    if (unlistedSymbols.length > 0) {
                        console.log(`Removed ${unlistedSymbols.length} unlisted pairs:`, unlistedSymbols);
                    }
                    
                    console.log(`Active pairs after filtering: ${Object.keys(binanceSymbolMap).length}`);
                } else {
                    console.error('Invalid response from Binance fundingInfo API');
                }
            } catch (error) {
                console.error('Error fetching Binance funding intervals:', error);
            }
        }
        
        // Fetch Lighter markets
        async function fetchLighterMarkets() {
            try {
                console.log('Fetching Lighter markets...');
                const response = await fetch('https://mainnet.zklighter.elliot.ai/api/v1/orderBooks');
                const data = await response.json();
                console.log('Lighter API response:', data.code, 'Markets found:', data.order_books?.length);
                
                if (data.code === 200) {
                    lighterMarkets = {};
                    binanceSymbolMap = {};
                    
                    data.order_books.forEach(market => {
                        if (market.status === 'active') {
                            lighterMarkets[market.market_id] = market.symbol;
                            
                            // Create Binance symbol mapping
                            let binanceSymbol;
                            if (market.symbol === 'XPL') {
                                binanceSymbol = 'XPLUSDT';
                            } else if (market.symbol === '1000FLOKI') {
                                binanceSymbol = '1000FLOKIUSDT';
                            } else {
                                binanceSymbol = market.symbol + 'USDT';
                            }
                            binanceSymbolMap[market.symbol] = binanceSymbol;
                        }
                    });
                    
                    console.log(`Processed ${Object.keys(lighterMarkets).length} active markets`);
                }
            } catch (error) {
                console.error('Error fetching Lighter markets:', error);
            }
        }

        // WebSocket connection states
        let lighterWs = null;
        let lighterReconnectAttempts = 0;
        let lighterLastActivity = Date.now();
        
        // Connect to Lighter WebSocket
        function connectLighter() {
            // Clean up existing connection
            if (lighterWs && lighterWs.readyState === WebSocket.OPEN) {
                lighterWs.close();
            }
            
            console.log(`Attempting to connect to Lighter WebSocket... (attempt ${lighterReconnectAttempts + 1})`);
            lighterWs = new WebSocket('wss://mainnet.zklighter.elliot.ai/stream');
            
            lighterWs.onopen = () => {
                console.log('✅ Connected to Lighter WebSocket');
                lighterReconnectAttempts = 0; // Reset reconnection attempts
                lighterLastActivity = Date.now();
                
                // Subscribe to all markets with staggered timing for stability
                const marketIds = Object.keys(lighterMarkets);
                let subscribeIndex = 0;
                
                const subscribeNext = () => {
                    if (subscribeIndex >= marketIds.length) {
                        console.log(`Subscribed to ${Object.keys(binanceSymbolMap).length} Binance-listed markets`);
                        return;
                    }
                    
                    const marketId = marketIds[subscribeIndex];
                    const symbol = lighterMarkets[marketId];
                    
                    if (binanceSymbolMap[symbol] && lighterWs.readyState === WebSocket.OPEN) {
                        // Subscribe to orderbook updates
                        lighterWs.send(JSON.stringify({
                            type: 'subscribe',
                            channel: `order_book/${marketId}`
                        }));
                        
                        // Mark subscription time
                        symbolSubscriptionStatus[symbol] = Date.now();
                        symbolLastUpdate[symbol] = Date.now(); // Initialize last update time
                        
                        // Subscribe to market stats for funding rates with small delay
                        setTimeout(() => {
                            if (lighterWs.readyState === WebSocket.OPEN) {
                                lighterWs.send(JSON.stringify({
                                    type: 'subscribe',
                                    channel: `market_stats/${marketId}`
                                }));
                            }
                        }, 25);
                    }
                    
                    subscribeIndex++;
                    setTimeout(subscribeNext, 50); // Stagger subscriptions by 50ms
                };
                
                subscribeNext();
            };
            
            lighterWs.onmessage = (event) => {
                lighterLastActivity = Date.now();
                const data = JSON.parse(event.data);
                
                if (data.type === 'ping') {
                    lighterWs.send(JSON.stringify({ type: 'pong' }));
                    return;
                }
                if (data.type === 'pong') return;
                
                if (data.channel && data.channel.includes('order_book')) {
                    const marketId = parseInt(data.channel.split(':')[1]);
                    const symbol = lighterMarkets[marketId];
                    
                    if (symbol && binanceSymbolMap[symbol]) {
                        if (data.order_book) {
                            // Apply incremental update
                            applyOrderbookUpdate(
                                symbol, 
                                data.order_book.bids, 
                                data.order_book.asks
                            );
                            
                            // Validate and store orderbook data after update
                            validateAndStoreOrderbook(symbol, true);
                            
                            scheduleUpdate();
                        } else if (data.snapshot) {
                            // Handle snapshot if provided
                            initOrderbook(symbol);
                            const orderbook = lighterOrderbooks[symbol];
                            orderbook.bids.clear();
                            orderbook.asks.clear();
                            
                            if (data.snapshot.bids) {
                                data.snapshot.bids.forEach(bid => {
                                    const price = parseFloat(bid.price);
                                    const size = parseFloat(bid.size);
                                    if (size > 0) orderbook.bids.set(price, size);
                                });
                            }
                            
                            if (data.snapshot.asks) {
                                data.snapshot.asks.forEach(ask => {
                                    const price = parseFloat(ask.price);
                                    const size = parseFloat(ask.size);
                                    if (size > 0) orderbook.asks.set(price, size);
                                });
                            }
                            
                            orderbook.lastUpdate = Date.now();
                            symbolLastUpdate[symbol] = Date.now();
                            validateAndStoreOrderbook(symbol, true);
                            scheduleUpdate();
                        }
                    }
                    
                } else if (data.channel && data.channel.includes('market_stats')) {
                    const marketId = parseInt(data.channel.split(':')[1]);
                    const symbol = lighterMarkets[marketId];
                    
                    if (symbol && binanceSymbolMap[symbol] && data.market_stats) {
                        const fundingRate = parseFloat(data.market_stats.current_funding_rate || 0);
                        lighterFundingData[symbol] = fundingRate * 8; // Convert 1h to 8h
                        
                        scheduleUpdate();
                    }
                }
            };
            
            lighterWs.onerror = (error) => {
                console.error('❌ Lighter WebSocket error:', error);
            };
            
            lighterWs.onclose = (event) => {
                console.log('❌ Lighter WebSocket closed. Code:', event.code, 'Reason:', event.reason);
                lighterReconnectAttempts++;
                const delay = Math.min(1000 * Math.pow(1.5, lighterReconnectAttempts), 10000); // Faster reconnect, max 10s
                console.log(`Reconnecting in ${delay/1000} seconds...`);
                
                // Clear current orderbook data to force refresh on reconnect
                for (const symbol in lighterOrderbooks) {
                    lighterOrderbooks[symbol] = {
                        bids: new Map(),
                        asks: new Map(),
                        lastUpdate: Date.now()
                    };
                    // Reset symbol tracking
                    symbolLastUpdate[symbol] = 0;
                    symbolSubscriptionStatus[symbol] = 0;
                }
                
                setTimeout(() => {
                    connectLighter();
                }, delay);
            };
        }
        
        // Function to resubscribe to a specific symbol
        function resubscribeSymbol(marketId, symbol) {
            if (lighterWs && lighterWs.readyState === WebSocket.OPEN) {
                console.log(`Resubscribing to ${symbol} (market ${marketId})`);
                
                // Unsubscribe first
                lighterWs.send(JSON.stringify({
                    type: 'unsubscribe',
                    channel: `order_book/${marketId}`
                }));
                
                // Resubscribe after short delay
                setTimeout(() => {
                    if (lighterWs && lighterWs.readyState === WebSocket.OPEN) {
                        lighterWs.send(JSON.stringify({
                            type: 'subscribe',
                            channel: `order_book/${marketId}`
                        }));
                        symbolSubscriptionStatus[symbol] = Date.now();
                    }
                }, 100);
            }
        }
        
        // Monitor Lighter WebSocket health and individual symbol status
        setInterval(() => {
            const now = Date.now();
            if (lighterWs && lighterWs.readyState === WebSocket.OPEN) {
                // Send ping to keep connection alive
                try {
                    lighterWs.send(JSON.stringify({ type: 'ping' }));
                } catch (e) {
                    console.error('Failed to send ping to Lighter:', e);
                }
                
                // Check individual symbols for stale data
                Object.keys(lighterMarkets).forEach(marketId => {
                    const symbol = lighterMarkets[marketId];
                    if (!binanceSymbolMap[symbol]) return;
                    
                    const lastUpdate = symbolLastUpdate[symbol] || 0;
                    const timeSinceUpdate = now - lastUpdate;
                    
                    // If no update for 15 seconds, resubscribe
                    if (timeSinceUpdate > 15000) {
                        const lastResubscribe = symbolSubscriptionStatus[symbol] || 0;
                        const timeSinceResubscribe = now - lastResubscribe;
                        
                        // Only resubscribe if we haven't tried in the last 10 seconds
                        if (timeSinceResubscribe > 10000) {
                            console.warn(`${symbol} orderbook stale for ${Math.round(timeSinceUpdate/1000)}s, resubscribing...`);
                            resubscribeSymbol(marketId, symbol);
                        }
                    }
                });
                
                // Check overall connection health
                if (now - lighterLastActivity > 10000) {
                    console.warn('Lighter WebSocket inactive for 10s, reconnecting...');
                    lighterWs.close();
                }
            } else if (!lighterWs || lighterWs.readyState === WebSocket.CLOSED) {
                // Auto reconnect if closed
                console.warn('Lighter WebSocket is closed, attempting reconnect...');
                connectLighter();
            }
        }, 3000); // Check every 3 seconds for faster recovery

        // Binance WebSocket state
        let binanceWs = null;
        let binanceReconnectAttempts = 0;
        let binanceLastActivity = Date.now();
        
        // Connect to Binance WebSocket  
        function connectBinance() {
            // Clean up existing connection
            if (binanceWs && binanceWs.readyState === WebSocket.OPEN) {
                binanceWs.close();
            }
            
            const symbols = Object.values(binanceSymbolMap)
                .map(s => s.toLowerCase())
                .filter(s => s.includes('usdt'));
            
            if (symbols.length === 0) {
                console.log('No Binance symbols to connect to, waiting...');
                setTimeout(connectBinance, 5000);
                return;
            }
            
            const streams = [];
            symbols.forEach(symbol => {
                streams.push(`${symbol}@depth5@100ms`);
                streams.push(`${symbol}@markPrice@1s`);
            });
            
            const streamUrl = `wss://fstream.binance.com/stream?streams=${streams.join('/')}`;
            console.log(`Connecting to Binance WebSocket... (attempt ${binanceReconnectAttempts + 1})`);
            binanceWs = new WebSocket(streamUrl);
            
            binanceWs.onopen = () => {
                console.log(`✅ Connected to Binance WebSocket with ${symbols.length} symbols`);
                binanceReconnectAttempts = 0;
                binanceLastActivity = Date.now();
            };
            
            binanceWs.onmessage = (event) => {
                binanceLastActivity = Date.now();
                const msg = JSON.parse(event.data);
                
                if (msg.stream && msg.data) {
                    const data = msg.data;
                    const symbol = data.s;
                    
                    let lighterSymbol = null;
                    for (const [ls, bs] of Object.entries(binanceSymbolMap)) {
                        if (bs === symbol) {
                            lighterSymbol = ls;
                            break;
                        }
                    }
                    
                    if (lighterSymbol) {
                        if (!binanceData[lighterSymbol]) binanceData[lighterSymbol] = {};
                        
                        if (msg.stream.includes('depth')) {
                            if (data.b && data.b.length > 0) {
                                binanceData[lighterSymbol].bid = parseFloat(data.b[0][0]);
                            }
                            if (data.a && data.a.length > 0) {
                                binanceData[lighterSymbol].ask = parseFloat(data.a[0][0]);
                            }
                            
                            // Validate and store Binance data
                            validateAndStoreOrderbook(lighterSymbol, false);
                            
                            scheduleUpdate();
                            
                        } else if (msg.stream.includes('markPrice')) {
                            const currentFundingRate = parseFloat(data.r || 0) * 100; // Convert to percentage
                            const nextFundingTime = parseInt(data.T || 0);
                            
                            // Get funding interval from Binance fundingInfo API data
                            const binanceSymbol = binanceSymbolMap[lighterSymbol];
                            let fundingInterval = binanceFundingIntervals[binanceSymbol] || 8;
                            
                            // Store raw funding rate and calculated interval
                            binanceData[lighterSymbol].rawFundingRate = currentFundingRate;
                            binanceData[lighterSymbol].fundingInterval = fundingInterval;
                            binanceData[lighterSymbol].nextFundingTime = nextFundingTime;
                            
                            // Convert to 8h equivalent for comparison with Lighter
                            let multiplier = 8 / fundingInterval; // 8시간 기준으로 배수 계산
                            binanceData[lighterSymbol].funding8h = currentFundingRate * multiplier;
                            
                            scheduleUpdate();
                        }
                    }
                }
            };
            
            binanceWs.onerror = (error) => {
                console.error('❌ Binance WebSocket error:', error);
            };
            
            binanceWs.onclose = (event) => {
                console.log('❌ Binance WebSocket closed. Code:', event.code);
                binanceReconnectAttempts++;
                const delay = Math.min(1000 * Math.pow(1.5, binanceReconnectAttempts), 10000); // Faster reconnect, max 10s
                console.log(`Reconnecting in ${delay/1000} seconds...`);
                setTimeout(connectBinance, delay);
            };
        }
        
        // Monitor Binance WebSocket health
        setInterval(() => {
            const now = Date.now();
            if (binanceWs && binanceWs.readyState === WebSocket.OPEN) {
                // Check if we haven't received data for 10 seconds
                if (now - binanceLastActivity > 10000) {
                    console.warn('Binance WebSocket inactive for 10s, reconnecting...');
                    binanceWs.close();
                }
            } else if (!binanceWs || binanceWs.readyState === WebSocket.CLOSED) {
                // Auto reconnect if closed
                console.warn('Binance WebSocket is closed, attempting reconnect...');
                connectBinance();
            }
        }, 3000); // Check every 3 seconds for faster recovery

        // Sorting state
        let sortColumn = 'fundingDiff';
        let sortDirection = 'desc';

        // Update table
        function updateTable() {
            const tbody = document.getElementById('tableBody');
            const rows = [];
            
            Object.keys(lighterMarkets).forEach(marketId => {
                const symbol = lighterMarkets[marketId];
                
                // Skip if not listed on Binance
                if (!binanceSymbolMap[symbol]) {
                    return; // Skip unlisted pairs
                }
                
                const lighter = getBestPrices(symbol);
                let binance = binanceData[symbol] || {};
                
                // Use last valid Binance data if current data is unavailable but recent
                const MAX_AGE = 60000; // 60 seconds for better persistence
                if ((!binance.bid || !binance.ask) && lastValidBinanceData[symbol]) {
                    const age = Date.now() - lastValidBinanceData[symbol].timestamp;
                    if (age < MAX_AGE) {
                        binance = {
                            ...binance,
                            bid: binance.bid || lastValidBinanceData[symbol].bid,
                            ask: binance.ask || lastValidBinanceData[symbol].ask
                        };
                    }
                }
                
                const lighterFunding = lighterFundingData[symbol] || 0;
                const binanceFunding8hEquiv = binance.funding8h || 0;
                const fundingDiff = lighterFunding - binanceFunding8hEquiv;
                
                // Calculate ratios only if we have valid prices, otherwise show N/A
                let lBidBAskRatio = null;
                let lAskBBidRatio = null;
                
                const hasValidLighterPrices = lighter.bid > 0 && lighter.ask > 0 && lighter.ask > lighter.bid;
                const hasValidBinancePrices = binance.bid > 0 && binance.ask > 0 && binance.ask > binance.bid;
                
                if (hasValidLighterPrices && hasValidBinancePrices) {
                    lBidBAskRatio = lighter.bid / binance.ask;
                    lAskBBidRatio = lighter.ask / binance.bid;
                }
                
                // Calculate funding countdown
                const now = Date.now();
                const nextFundingTime = binance.nextFundingTime || 0;
                const fundingCountdown = nextFundingTime ? Math.max(0, Math.floor((nextFundingTime - now) / 1000)) : 0;
                
                // Get raw funding data from Binance
                const rawBinanceFunding = binance.rawFundingRate || 0;
                const fundingInterval = binance.fundingInterval || 8;
                
                // Always show the row, even with partial data
                rows.push({
                    symbol,
                    lighterFunding,
                    binanceFunding: rawBinanceFunding, // Show raw rate
                    binanceFunding8h: binanceFunding8hEquiv, // 8h equivalent for comparison
                    fundingInterval,
                    fundingDiff,
                    lighterBid: lighter.bid,
                    lighterAsk: lighter.ask,
                    binanceBid: binance.bid,
                    binanceAsk: binance.ask,
                    lBidBAskRatio,
                    lAskBBidRatio,
                    hasValidData: hasValidLighterPrices && hasValidBinancePrices,
                    nextFundingTime,
                    fundingCountdown
                });
            });
            
            // Sort rows
            rows.sort((a, b) => {
                let aVal = a[sortColumn] || 0;
                let bVal = b[sortColumn] || 0;
                
                if (typeof aVal === 'number' && typeof bVal === 'number') {
                    return sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
                }
                
                return sortDirection === 'asc' ? 
                    String(aVal).localeCompare(String(bVal)) : 
                    String(bVal).localeCompare(String(aVal));
            });
            
            // Build table HTML
            tbody.innerHTML = rows.map(row => {
                const lBidBAskColor = row.lBidBAskRatio !== null ? 
                    (row.lBidBAskRatio < 1 ? 'positive' : row.lBidBAskRatio > 1 ? 'negative' : 'neutral') : 'neutral';
                const lAskBBidColor = row.lAskBBidRatio !== null ? 
                    (row.lAskBBidRatio > 1 ? 'positive' : row.lAskBBidRatio < 1 ? 'negative' : 'neutral') : 'neutral';
                
                // Format prices and ratios with fallbacks and infinity checks
                const lighterBidStr = row.lighterBid ? row.lighterBid.toFixed(6) : 'N/A';
                const lighterAskStr = row.lighterAsk ? row.lighterAsk.toFixed(6) : 'N/A';
                const binanceBidStr = row.binanceBid ? row.binanceBid.toFixed(6) : 'N/A';
                const binanceAskStr = row.binanceAsk ? row.binanceAsk.toFixed(6) : 'N/A';
                
                // Handle infinity and null values for ratios
                const lBidBAskStr = (row.lBidBAskRatio !== null && isFinite(row.lBidBAskRatio)) ? 
                    row.lBidBAskRatio.toFixed(5) : 'N/A';
                const lAskBBidStr = (row.lAskBBidRatio !== null && isFinite(row.lAskBBidRatio)) ? 
                    row.lAskBBidRatio.toFixed(5) : 'N/A';
                
                // Format funding countdown
                const formatCountdown = (seconds) => {
                    if (!seconds) return 'N/A';
                    const hours = Math.floor(seconds / 3600);
                    const minutes = Math.floor((seconds % 3600) / 60);
                    const secs = seconds % 60;
                    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                };
                
                const countdownStr = formatCountdown(row.fundingCountdown);
                const nextFundingStr = row.nextFundingTime ? 
                    new Date(row.nextFundingTime).toLocaleTimeString('en-US', { hour12: false }) : 'N/A';
                    
                // Format funding interval display with color coding
                let intervalDisplay = `${row.fundingInterval}h`;
                let intervalColor = '';
                if (row.fundingInterval === 1) {
                    intervalColor = 'color: #dc2626; font-weight: bold;'; // Red for 1h
                } else if (row.fundingInterval === 4) {
                    intervalColor = 'color: #d97706; font-weight: bold;'; // Orange for 4h
                } else {
                    intervalColor = 'color: #059669;'; // Green for 8h
                }
                
                // Add visual indicator for missing data
                const rowClass = row.hasValidData ? '' : 'opacity: 0.6;';
                
                return `
                <tr style="${rowClass}">
                    <td><strong>${row.symbol}</strong></td>
                    <td>${row.lighterFunding.toFixed(6)}%</td>
                    <td title="Raw funding rate per ${intervalDisplay} interval">
                        ${isFinite(row.binanceFunding) ? row.binanceFunding.toFixed(6) : 'N/A'}% 
                        <span style="${intervalColor}">(${intervalDisplay})</span>
                    </td>
                    <td title="8-hour equivalent for comparison">
                        ${isFinite(row.binanceFunding8h) ? row.binanceFunding8h.toFixed(6) : 'N/A'}%
                    </td>
                    <td class="${row.fundingDiff > 0 ? 'positive' : row.fundingDiff < 0 ? 'negative' : 'neutral'}">
                        ${isFinite(row.fundingDiff) ? (row.fundingDiff > 0 ? '+' : '') + row.fundingDiff.toFixed(6) + '%' : 'N/A'}
                    </td>
                    <td class="neutral" title="Next funding at ${nextFundingStr}" style="font-size: 12px;">
                        ${countdownStr}
                    </td>
                    <td class="${lBidBAskColor}" title="L Bid: ${lighterBidStr} / B Ask: ${binanceAskStr}">
                        ${lBidBAskStr}
                    </td>
                    <td class="${lAskBBidColor}" title="L Ask: ${lighterAskStr} / B Bid: ${binanceBidStr}">
                        ${lAskBBidStr}
                    </td>
                </tr>`;
            }).join('');
            
            document.getElementById('updateTime').textContent = 
                `Last update: ${new Date().toLocaleTimeString()} | ${rows.length} pairs`;
        }

        // Setup sorting
        function setupSorting() {
            document.querySelectorAll('.sortable').forEach(header => {
                header.addEventListener('click', () => {
                    const column = header.dataset.sort;
                    if (sortColumn === column) {
                        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn = column;
                        sortDirection = 'desc';
                    }
                    
                    document.querySelectorAll('.sortable').forEach(h => h.innerHTML = h.innerHTML.replace(/ [↑↓]/, ''));
                    header.innerHTML = header.innerHTML.replace(' ↕', '') + (sortDirection === 'asc' ? ' ↑' : ' ↓');
                    
                    updateTable();
                });
            });
        }

        // Initialize
        async function init() {
            await fetchLighterMarkets(); // Get Lighter markets first
            await fetchBinanceFundingIntervals(); // Then get funding intervals for those symbols
            connectLighter();
            setTimeout(connectBinance, 1000);
            setupSorting();
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log('Page loaded, starting initialization...');
            init();
        });
    </script>
</body>
</html>